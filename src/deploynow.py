#!/usr/bin/env python

"""
______           _             _   _               
|  _  \         | |           | \ | |              
| | | |___ _ __ | | ___  _   _|  \| | _____      __
| | | / _ | '_ \| |/ _ \| | | | . ` |/ _ \ \ /\ / /
| |/ |  __| |_) | | (_) | |_| | |\  | (_) \ V  V / 
|___/ \___| .__/|_|\___/ \__, \_| \_/\___/ \_/\_/  
          | |             __/ |                    
          |_|            |___/                     
Upload and deploy a package using CodeDeploy, all in one go.
"""

from botocore.exceptions import ClientError
from .color import print_err, print_muted, print_success, print_warning
import argparse
import boto3
import shutil
import os
import time

session = boto3.Session()


def get_timestamp_str():
    # To get a string without a . we make the timestamp an integer first.
    return str(int(time.time()))


def push_to_s3(application_name, source_directory, s3_bucket, s3_prefix, region):
    """
    This method will zip a given directory, and upload the zipped file to a S3 bucket,
    under the given prefix.
    Ex:
        If prefix is app/dev/ and application name is some-app --> Artifact path will be app/dev/some-app.1562067717.zip
        where 1562067717 is the timestamp.

    :param application_name
        Name of the CodeDeploy application name.
    :param source_directory
        Path to the source directory.
    :param s3_bucket
        Name of the destination S3 bucket.
        NOTE: Only the name should be provided without s3:// prefix.
    :param s3_prefix
        Folder structure within S3.
        Ex:
            app/dev/
        NOTE: Should begin without a slash.
    :param region
        Region code of the region in which the S3 bucket is created.

    :returns object path
        Path to the uploaded object. 
    """

    print('._ [ RUN ]  Creating revision in S3')

    # Validate inputs.
    if not os.path.isdir(source_directory):
        print_err("|_ [ ERR ]  The source directory {directory} does not exist.".format(
            directory=source_directory))
        exit(1)
    if not s3_prefix.endswith('/'):
        s3_prefix = s3_prefix + '/'
    if s3_prefix.startswith('/'):
        s3_prefix.replace('/', '', 1)  # replace first slash only.

    # Zip.
    timestamp = get_timestamp_str()
    # .zip extension is added automatically.
    archive_name = "{application_name}.{timestamp}.zip".format(
        application_name=application_name, timestamp=timestamp)
    archive_path = "/tmp/{archive_name}".format(archive_name=archive_name)

    print('|_ [ RUN ]  Archiving {source} as {destination}'.format(
        source=source_directory, destination=archive_path))
    shutil.make_archive(archive_path.replace(
        '.zip', ''), 'zip', source_directory)
    print_success('|_ [ OK ]   Successfully archived')


    # Upload to S3.
    s3_object_path = s3_prefix + archive_name
    try:
        s3 = session.client('s3', region_name=region)

        print('|_ [ RUN ]  Uploading artifact {artifact} to bucket {bucket} as {object_path}'.format(
            artifact=archive_path, bucket=s3_bucket, object_path=s3_object_path))
        s3.upload_file(archive_path, s3_bucket, s3_object_path)
        print_success('|_ [ OK ]   Uploaded to S3 successfully')

    except Exception as e:
        print_err('|_ [ ERR ]  Unable to upload to {bucket} in {region}.\n   {e}'.format(
            bucket=s3_bucket, region=region, e=e))
        s3_object_path = None

    print('|\n|')

    return s3_object_path


def deploy(application_name, s3_bucket, s3_artifact_path, region, deployment_group, deployment_config='CodeDeployDefault.OneAtATime', description=''):
    """
    This will create a deployment in CodeDeploy for the provided application.

    :param application_name
        Name of the CodeDeploy application name.
    :param s3_bucket
        Name of the destination S3 bucket.
        NOTE: Only the name should be provided without s3:// prefix.
    :param s3_artifact_path
        S3 location of the revision/artifact.
    :param region
        Region code of the region in which the S3 bucket is created.
    :param deployment_group
        Name of the deployment group associated with the application.
    :param deployment_config
        OPTIONAL
        DEFAULT: CodeDeployDefault.OneAtATime
        Name of the deployment configuration associated with the application.
    :param description
        OPTIONAL
        DEFAULT: ''
        Description of the deployment

    :returns deployment id
        Deployment ID generated by CodeDeploy
    """

    codedeploy = session.client('codedeploy', region_name=region)
    deployment_id = None

    try:
        print('._ [ RUN ]  Creating deployment for application {application} under deployment group {group} with configuration {config}'.format(
            application=application_name, group=deployment_group, config=deployment_config))

        response = codedeploy.create_deployment(
            applicationName=application_name,
            deploymentGroupName=deployment_group,
            deploymentConfigName=deployment_config,
            description=description,
            revision={
                'revisionType': 'S3',
                's3Location': {
                    'bucket': s3_bucket,
                    'key': s3_artifact_path,
                    'bundleType': 'zip'
                }
            }
        )

        deployment_id = response['deploymentId'] if 'deploymentId' in response.keys(
        ) else None

        if deployment_id is not None:
            print_success('|_ [ OK ]   Deploying {application} to {group} using config {config} under deployment id {id}'.format(
                application=application_name, group=deployment_group, config=deployment_config, id=deployment_id))
        else:
            raise Exception('|_ [ ERR ] Received unexpected response from CodeDeploy\n   {response}'.format(
                response=response))

    except Exception as e:
        e = str(e)
        deployment_id = None

        if 'ApplicationDoesNotExistException' in e:
            print_err('|_ [ ERR ]  Application {application} does not exist in CodeDeploy'.format(
                application=application_name))
        elif 'DeploymentGroupDoesNotExistException' in e:
            print_err('|_ [ ERR ]  Deployment group {group} does not exist in application {application}'.format(
                group=deployment_group, application=application_name))
        elif 'DeploymentConfigDoesNotExistException' in e:
            print_err('|_ [ ERR ]  Deploymeny configuration {config} does not exist'.format(
                config=deployment_config))
        elif 'DeploymentLimitExceededException' in e:
            # Return the deployment id of the ongoing deployment.
            # Ex: d-QR8AO4P4B
            deployment_id = e[e.index("'d-"): len(e)
                              ].replace("'", '') if "'d-" in e else None
            print_warning('|_ [ WARN ] Deployment {id} is already in progress'.format(
                id=deployment_id))
        else:
            print_err('|_ [ ERR ] Unknown error occured.\n   {e}'.format(e=e))

    print('|\n|')

    return deployment_id


def deployment_progress(deployment_id, region):
    """
    Returns the current status of a CodeDeploy deployment.

    :param deployment_id
        ID generated by CodeDeploy when a deployment is created.
    :param region
        AWS region to which the CodeDeploy application belongs to.

    :returns dict
        A dictionary containing information about the deployment.
        --> Status: Created | Queued | InProgress | Succeeded | Failed | Stopped | Ready 
        --> Overview: <Number of deployments under each criteria listed above>

        NOTE: If the status is not one of the above, the Overview wil contain the error.

        NOTE: Since this method will be called reportadly, do not call unnecessary print statements.
    """

    codedeploy = session.client('codedeploy', region_name=region)
    status = {'Status': 'Error', 'Overview': 'N/A'}

    try:
        response = codedeploy.get_deployment(deploymentId=deployment_id)

        if 'deploymentInfo' in response.keys() and 'status' in response['deploymentInfo'].keys():
            overall_deployment_status = response['deploymentInfo']['status']
            deployment_overview = response['deploymentInfo']['deploymentOverview'] if 'deploymentOverview' in response['deploymentInfo'].keys() else {
            }
            status = {
                'Status': overall_deployment_status, 'Overview': deployment_overview}
        else:
            raise Exception('|_ [ ERR ]  Unable to retrieve deployment status.\n   {response}'.format(
                response=response))

    except Exception as e:
        e = str(e)
        if 'InvalidDeploymentIdException' in e:
            print_err('|_ [ ERR ]  Deploymeny id {id} can not be found in {region}'.format(
                id=deployment_id, region=region))
            status['Overview'] = '|_ [ ERR ]  Deploymeny id {id} can not be found in {region}'.format(
                id=deployment_id, region=region)
        else:
            print_err('[ ERR ]  Unknown error occured.\n   {e}'.format(e=e))
            status['Overview'] = e

    return status


def monitor_deployment(deployment_id, region):
    """
    This will check the status of the deployment every 5 seconds,
    until the deployment finishes.

    NOTE: Status being Succeeded | Failed | Stopped is considered as deployment finished.

    :param deployment_id
        ID generated by CodeDeploy when a deployment is created.
    :param region
        AWS region to which the CodeDeploy application belongs to.
    """

    print('._ [ RUN ]  Monitoring deployment..')

    progress = deployment_progress(deployment_id, region)
    status = progress['Status']

    if status == 'Error':
        print_err('|_ [ ERR ]  Unable to monitor deployment {id}.\n   {reason}'.format(
            id=deployment_id, reason=progress['Overview']))
        exit(1)

    print('|_ [ RUN ]  Deployment {id} is in progress...'.format(
        id=deployment_id))

    while status != 'Error':
        progress = deployment_progress(deployment_id, region)
        status = progress['Status']

        if status in ('Created', 'Queued', 'InProgress', 'Ready'):
            pass

        elif status == 'Succeeded':
            print_success('|_ [ OK ]   Deployment {id} completed successfully'.format(
                id=deployment_id))

            # Print summary/overview.
            overview = progress['Overview']
            for key, value in overview.items():
                print_success('\t{criteria}\t{count}'.format(
                    criteria=key, count=value))

            exit(0)

        elif status in ('Failed', 'Stopped'):
            print_err('|_ [ ERR ]  Deployment {id} failed'.format(
                id=deployment_id))

            # Print summary/overview.
            overview = progress['Overview']
            for key, value in overview.items():
                print_err('\t{criteria}\t{count}'.format(
                    criteria=key, count=value))
            exit(1)

        else:
            print_err('|_ [ ERR ]  Unknown error occured\n   {overview}'.format(
                overview=overview))

        # Wait a bit before each iteration to avoid request throttling.
        time.sleep(5)
        
def arguments():
    parser = argparse.ArgumentParser(
        description='CodeDeployNow can be used to zip a source directory and deploy it via AWS CodeDeploy and monitor the deployment status all in one go.')

    parser.add_argument('-a', '--application-name',
                        help='Name of the CodeDeploy application', required=True)
    parser.add_argument('-d', '--deployment-group',
                        help='Deployment group to which the deployment will be pushed', required=True)
    parser.add_argument('-c', '--deployment-config',
                        help='Deployment configuration.', required=True)
    parser.add_argument(
        '-s', '--source', help='Path to source directory', required=True)
    parser.add_argument(
        '-b', '--bucket', help='Name of the S3 bucket to store the artifact', required=True)
    parser.add_argument(
        '-p', '--prefix', help='Additional S3 prefix to structure the artifact storage', default='', required=True)
    parser.add_argument(
        '-r', '--region', help='AWS region code', required=True)
    parser.add_argument('--ignore-progress', action='store_true',
                        help='Settings this flag will make the application quit after deployment is created')

    args = parser.parse_args()

    # Validate arguments.
    args = vars(args)
    allowed_regions = ['us-east-2', 'us-east-1', 'us-west-1', 'us-west-2', 'ap-east-1', 'ap-south-1', 'ap-northeast-2', 'ap-southeast-1', 'ap-southeast-2', 'ap-northeast-1',
                       'ca-central-1', 'cn-north-1', 'cn-northwest-1', 'eu-central-1', 'eu-west-1', 'eu-west-2', 'eu-west-3', 'eu-north-1', 'sa-east-1', 'us-gov-east-1', 'us-gov-west-1']

    if args['region'] not in allowed_regions:
        print_err('[ ERR ]  Invalid region:- {region}\n   Allowed values for region are:-\n\t{allowed_values}'.format(
            region=args['region'], allowed_values='\n\t'.join(allowed_regions)))
        exit(1)

    return args


def main():
    """
    The boss :P
    Once required parameters are provided(as command line arguments),
    the goal is to archive the source directory and push it to S3, and
    deploy the same archive via CodeDeploy and then monitor the status of
    the deployment till it finishes.

    NOTE: User can choose not to monitor the status of the deployment by
    passing --ignore-progress flag.

    NOTE: Required parameters are as follows.
    application-name, source, bucket, prefix, region
    """

    # Capture command line arguments.
    args = arguments()
    application_name, source, bucket, prefix, region, deployment_group, deployment_config, ignore_progress = args['application_name'], args[
        'source'], args['bucket'], args['prefix'], args['region'], args['deployment_group'], args['deployment_config'], args['ignore_progress']

    revision = push_to_s3(application_name, source, bucket, prefix, region)

    if (revision is not None):
        # Start deployment.
        deployment_id = deploy(application_name, bucket,
                               revision, region, deployment_group, deployment_config=deployment_config)

        # Monitor deployment progress till it finishes, if user has specified.
        if not ignore_progress:
            monitor_deployment(deployment_id, region)
        else:
            print_warning(
                '[ WARN ]  --ignore-progress flag is set, therefore deployment progress will not be monitored.')
